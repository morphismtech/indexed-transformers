{-# LANGUAGE
    ConstraintKinds
  , DefaultSignatures
  , GADTs
  , PolyKinds
  , QuantifiedConstraints
  , RankNTypes
  , UndecidableInstances
#-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}

module Control.Monad.Trans.Indexed.Free
  ( IxFree (liftIxFree, hoistIxFree, runIxFree), coerceIxFree
  , IxFunctor, IxMap (IxMap), liftIxFreer, hoistIxFreer
  ) where

import Control.Monad.Free
import Control.Monad.Trans.Indexed
import Data.Kind

{- |
The free `IndexedMonadTrans` generated by an `IxFunctor`
is characterized by the `IxFree` class
up to the isomorphism `coerceIxFree`.

`IxFree` and `IxMap`, the free `IndexedMonadTrans` and
the free `IxFunctor`, can be combined as a "freer" `IndexedMonadTrans`
and used as a DSL generated by primitive commands like this
[Conor McBride example]
(https://stackoverflow.com/questions/28690448/what-is-indexed-monad).

>>> :set -XGADTs -XDataKinds
>>> import Data.Kind
>>> type DVD = String
>>> :{
data DVDCommand
  :: Bool -- ^ drive is full before command
  -> Bool -- ^ drive is full after command
  -> Type -- ^ return type
  -> Type where
  Insert :: DVD -> DVDCommand 'False 'True ()
  Eject :: DVDCommand 'True 'False DVD
:}

>>> :{
insert
  :: (IxFree free, Monad m)
  => DVD -> free (IxMap DVDCommand) 'False 'True m ()
insert dvd = liftIxFreer (Insert dvd)
:}

>>> :{
eject
  :: (IxFree free, Monad m)
  => free (IxMap DVDCommand) 'True 'False m DVD
eject = liftIxFreer Eject
:}

>>> :set -XQualifiedDo
>>> import qualified Control.Monad.Trans.Indexed.Do as Indexed
>>> :{
swap
  :: (IxFree free, Monad m)
  => DVD -> free (IxMap DVDCommand) 'True 'True m DVD
swap dvd = Indexed.do
  dvd' <- eject
  insert dvd
  return dvd'
:}

-}
class
  ( forall f. IxFunctor f => IndexedMonadTrans (free f)
  , forall f m i j. (IxFunctor f, Monad m, i ~ j)
    => MonadFree (f i j) (free f i j m)
  ) => IxFree free where
  liftIxFree
    :: (IxFunctor f, Monad m)
    => f i j x
    -> free f i j m x
  hoistIxFree
    :: (IxFunctor f, IxFunctor g, Monad m)
    => (forall i j x. f i j x -> g i j x)
    -> free f i j m x -> free g i j m x
  runIxFree
    :: (IxFunctor f, IndexedMonadTrans t, Monad m)
    => (forall i j x. f i j x -> t i j m x)
    -> free f i j m x -> t i j m x

{- |
prop> coerceIxFree = runIxFree liftIxFree
-}
coerceIxFree
  :: (IxFree free0, IxFree free1, IxFunctor f, Monad m)
  => free0 f i j m x -> free1 f i j m x 
coerceIxFree = runIxFree liftIxFree

type IxFunctor
  :: (k -> k -> Type -> Type)
  -> Constraint
type IxFunctor f = forall i j. Functor (f i j)

{- |
`IxMap` is the free `IxFunctor`. It's a left Kan extension.
Combining `IxFree` with `IxMap` as demonstrated in the above example,
gives the "freer" `IndexedMonadTrans`, modeled on this
[Oleg Kiselyov explanation]
(https://okmij.org/ftp/Computation/free-monad.html#freer).
-}
data IxMap f i j x where
  IxMap :: (x -> y) -> f i j x -> IxMap f i j y
instance Functor (IxMap f i j) where
  fmap g (IxMap f x) = IxMap (g . f) x

liftIxFreer
  :: (IxFree free, Monad m)
  => f i j x -> free (IxMap f) i j m x
liftIxFreer x = liftIxFree (IxMap id x)

hoistIxFreer
  :: (IxFree free, Monad m)
  => (forall i j x. f i j x -> g i j x)
  -> free (IxMap f) i j m x -> free (IxMap g) i j m x
hoistIxFreer f = hoistIxFree (\(IxMap g x) -> IxMap g (f x))
