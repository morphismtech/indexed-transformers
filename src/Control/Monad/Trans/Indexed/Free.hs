{-# LANGUAGE
    ConstraintKinds
  , DefaultSignatures
  , GADTs
  , PolyKinds
  , QuantifiedConstraints
  , RankNTypes
  , UndecidableInstances
#-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}

module Control.Monad.Trans.Indexed.Free
  ( IxFree (ixlift, ixhoist, ixfoldMap), coerceIxFree
  , IxFunctor, IxMap (IxMap), hoistIxMap, liftIxMap, lowerIxMap
  ) where

import Control.Monad.Free
import Control.Monad.Trans.Indexed
import Data.Kind

{- |
The free `IndexedMonadTrans` generated by an `IxFunctor`
is characterized by the `IxFree` class
up to the isomorphism `coerceIxFree`.

`IxFree` and `IxMap`, the free `IndexedMonadTrans` and
the free `IxFunctor` can be used as a DSL
generated by primitive commands like [this Conor McBride example]
(https://stackoverflow.com/questions/28690448/what-is-indexed-monad).

>>> :set -XGADTs -XDataKinds
>>> import Data.Kind
>>> type DVD = String
>>> :{
data DVDCommand
  :: Bool -- ^ drive is full before command
  -> Bool -- ^ drive is full after command
  -> Type -- ^ return type
  -> Type where
  Insert :: DVD -> DVDCommand 'False 'True ()
  Eject :: DVDCommand 'True 'False DVD
:}

>>> :{
insert
  :: (IxFree free, Monad m)
  => DVD -> free (IxMap DVDCommand) 'False 'True m ()
insert dvd = ixlift (liftIxMap (Insert dvd))
:}

>>> :{
eject
  :: (IxFree free, Monad m)
  => free (IxMap DVDCommand) 'True 'False m DVD
eject = ixlift (liftIxMap Eject)
:}

>>> :set -XQualifiedDo
>>> import qualified Control.Monad.Trans.Indexed.Do as Indexed

>>> :{
swap
  :: (IxFree free, Monad m)
  => DVD -> free (IxMap DVDCommand) 'True 'True m DVD
swap dvd = Indexed.do
  dvd' <- eject
  insert dvd
  return dvd'
:}

-}
class
  ( forall f. IxFunctor f => IndexedMonadTrans (free f)
  , forall f m i j. (IxFunctor f, Monad m, i ~ j)
    => MonadFree (f i j) (free f i j m)
  ) => IxFree free where
  ixlift
    :: (IxFunctor f, Monad m)
    => f i j x
    -> free f i j m x
  ixhoist
    :: (IxFunctor f, IxFunctor g, Monad m)
    => (forall i j x. f i j x -> g i j x)
    -> free f i j m x -> free g i j m x
  ixfoldMap
    :: (IxFunctor f, IndexedMonadTrans t, Monad m)
    => (forall i j x. f i j x -> t i j m x)
    -> free f i j m x -> t i j m x

{- |
prop> coerceIxFree = ixfoldMap ixlift
-}
coerceIxFree
  :: (IxFree free0, IxFree free1, IxFunctor f, Monad m)
  => free0 f i j m x -> free1 f i j m x 
coerceIxFree = ixfoldMap ixlift

type IxFunctor
  :: (k -> k -> Type -> Type)
  -> Constraint
type IxFunctor f = forall i j. Functor (f i j)

{- |

-}
data IxMap f i j x where
  IxMap :: (x -> y) -> f i j x -> IxMap f i j y
instance Functor (IxMap f i j) where
  fmap g (IxMap f x) = IxMap (g . f) x
hoistIxMap
  :: (forall x. f i j x -> g i j x)
  -> IxMap f i j x -> IxMap g i j x
hoistIxMap g (IxMap f x) = IxMap f (g x)
liftIxMap :: g i j x -> IxMap g i j x
liftIxMap = IxMap id
lowerIxMap :: Functor (g i j) => IxMap g i j x -> g i j x
lowerIxMap (IxMap f x) = fmap f x
